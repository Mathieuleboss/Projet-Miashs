import math
import random
import time
import matplotlib.pyplot as plt

from matplotlib.colors import LinearSegmentedColormap

colors = [
    (0.0, 'deepskyblue'),  # bleu
    (0.25, 'forestgreen'),  # vert
    (0.5, 'orange'),  # orange (au lieu de 'goldenrod' pour le jaune)
    (1.0, 'lightgray')  # gris
]
reduced_cmap = LinearSegmentedColormap.from_list('reduced', colors)

# Constants for Perlin noise
PERLIN_SIZE = 512
PERLIN_SCALE = 16
PERSISTENCE = 0.5
LACUNARITY = 2.0
NUM_OCTAVES = 16

# Perlin noise table
perlin = [[0 for _ in range(PERLIN_SIZE)] for _ in range(PERLIN_SIZE)]

def apply_contrast(values, factor=20):
    min_value = min(min(row) for row in values)
    max_value = max(max(row) for row in values)
    new_values = [[0 for _ in range(len(values[0]))] for _ in range(len(values))]
    for x in range(len(values)):
        for y in range(len(values[x])):
            new_values[x][y] = ((values[x][y] - min_value) / (max_value - min_value)) ** factor
    return new_values

# Function to linearly interpolate between a0 and a1
def lerp(a0, a1, w):
    return a0 + w * (a1 - a0)

# Fade function for Perlin noise
def fade(t):
    return t ** 3 * (t * (t * 6 - 15) + 10)

# Function to generate Perlin noise
def generate_perlin_noise():
    for i in range(PERLIN_SIZE):
        for j in range(PERLIN_SIZE):
            perlin[i][j] = random.random()

# Function to generate a single octave of Perlin noise
seed = int(time.time())

def generate_noise(width, height, scale):
    values = [[0 for _ in range(width)] for _ in range(height)]

    for x in range(width):
        for y in range(height):
            value = perlin_noise((x + seed) / scale, (y + seed) / scale, 0)
            values[x][y] = value

    return values
# Function to generate a height map using multiple octaves of Perlin noise
def generate_height_map(width, height, scale):
    values = [[0 for _ in range(width)] for _ in range(height)]

    # Generate height maps for each biome
    ocean_map = generate_noise(width, height, scale * 4)
    forest_map = generate_noise(width, height, scale * 2)
    desert_map = generate_noise(width, height, scale)
    mountain_map = generate_noise(width, height, scale * 0.5)

    # Combine height maps
    for x in range(width):
        for y in range(height):
            ocean_value = ocean_map[x][y]
            forest_value = forest_map[x][y]
            desert_value = desert_map[x][y]
            mountain_value = mountain_map[x][y]
            values[x][y] = max(ocean_value, forest_value, desert_value, mountain_value)

    # Apply color map
    for x in range(width):
        for y in range(height):
            value = values[x][y]
            if value < 0.25:
                # Ocean
                values[x][y] = 0
            elif value < 0.5:
                # Desert
                values[x][y] = 1.8
            elif value < 0.75:
                # Forest
                values[x][y] = 1
            else:
                # Mountains
                values[x][y] = 3

    return values

# Function to calculate Perlin noise
def perlin_noise(x, y, octave):
    x0 = math.floor(x)
    x1 = x0 + 1
    y0 = math.floor(y)
    y1 = y0 + 1
    sx = x - x0
    sy = y - y0

    n00 = perlin[x0 & (PERLIN_SIZE - 1)][y0 & (PERLIN_SIZE - 1)]
    n01 = perlin[x0 & (PERLIN_SIZE - 1)][y1 & (PERLIN_SIZE - 1)]
    n10 = perlin[x1 & (PERLIN_SIZE - 1)][y0 & (PERLIN_SIZE - 1)]
    n11 = perlin[x1 & (PERLIN_SIZE - 1)][y1 & (PERLIN_SIZE - 1)]

    u = fade(sx)
    v = fade(sy)
    n0 = lerp(n00, n01, v)
    n1 = lerp(n10, n11, v)
    n = lerp(n0, n1, u)

    # Modification : donner plus de poids aux valeurs basses

    return n if octave == 0 else n / 2 ** octave
def plot_color_gradients(title, colormaps):
    """Plot color gradients for a given list of colormaps."""
    num_colormaps = len(colormaps)
    fig, axs = plt.subplots(nrows=1, ncols=num_colormaps, figsize=(15, 0.5))
    fig.suptitle(title, fontsize=14, fontweight='bold')
    for i, cmap in enumerate(colormaps):
        ax = axs[i]
        ax.imshow([[0, 10]], aspect='auto', cmap=plt.get_cmap(cmap))
        ax.axis('off')
    plt.show()
# Function to display the height map
def display_height_map(map):
    """Display the height map using Matplotlib."""
    fig, ax = plt.subplots()
    im = ax.imshow(map, cmap=reduced_cmap, vmin=0, vmax=3)  # Use the reduced colormap and set the value range
    fig.colorbar(im, ax=ax)

    # Apply contrast to the height map
    contrast_factor = 20
    contrast_map = apply_contrast(map, contrast_factor)

    # Plot color gradients
    plt.imshow(contrast_map, cmap=reduced_cmap, vmin=0, vmax=3)  # Use the reduced colormap and set the value range
    plt.colorbar()
    plt.show()
# Main function
def main():
    # Seed the random number generator
    seed = int(time.time())
    random.seed(seed)

    # Generate the Perlin noise table
    generate_perlin_noise()

    # Generate a height map with multiple octaves of Perlin noise
    width = 1050
    height = 1050
    scale = 25
    map = generate_height_map(width, height, scale)

    # Display the height map
    display_height_map(map)

if __name__ == '__main__':
    main()
