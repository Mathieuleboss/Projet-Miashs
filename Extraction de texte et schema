#Points améliorés :
#1 - Meilleure gestion des imports : Import uniquement des modules nécessaires.
#2 - Renommage des variables : Pour une meilleure lisibilité.
#3 - Suppression des commentaires redondants : Certains étaient explicites par le code lui-même.
#4 - Gestion des erreurs : Ajout d'une gestion des exceptions pour les fichiers PDF inexistants ou corrompus.
#5 - Modularisation : Séparation claire des responsabilités.
#6 - Nettoyage optionnel : Permettre de désactiver certaines parties du nettoyage via des paramètres.
#7 - Suppression des chemins et noms de fichiers codés en dur.

#Changements majeurs :
#1 - Gestion des erreurs : Le programme ne plante pas si le fichier PDF est introuvable ou corrompu.
#2 - Dossier de sortie pour les tableaux : Les fichiers CSV sont organisés dans un dossier spécifique.
#3 - Paramètres configurables : Le nettoyage des entêtes/pieds est optionnel via un paramètre.
#4 - Suppression des chemins et noms codés en dur : Le code est plus réutilisable.

import pdfplumber
import csv
import re
import os

def extraire_texte_nettoye(pdf_path, nettoyer_entetes_pieds=True):
    """
    Extrait et nettoie le texte d'un fichier PDF.
    
    Args:
        pdf_path (str): Chemin du fichier PDF.
        nettoyer_entetes_pieds (bool): Supprime les entêtes et pieds de page si True.
    
    Returns:
        str: Texte nettoyé du PDF.
    """
    texte_complet = ""

    try:
        with pdfplumber.open(pdf_path) as pdf:
            for page in pdf.pages:
                texte = page.extract_text()
                if texte:
                    # Nettoyer les sauts de ligne multiples
                    texte = re.sub(r'\n+', '\n', texte)

                    # Optionnel : Supprimer les entêtes/pieds de page répétitifs
                    if nettoyer_entetes_pieds:
                        texte = re.sub(r"(Licence MIASHS L2|Jean-François Pradat-Peyre|Université Paris Nanterre)", "", texte)

                    # Ajouter un séparateur entre les pages
                    texte_complet += texte.strip() + "\n\n"
    except Exception as e:
        print(f"Erreur lors de l'ouverture ou de la lecture du fichier PDF : {e}")
        return ""

    return texte_complet

def extraire_tableaux(pdf_path, dossier_sortie="tableaux"):
    """
    Extrait les tableaux d'un fichier PDF et les enregistre au format CSV.
    
    Args:
        pdf_path (str): Chemin du fichier PDF.
        dossier_sortie (str): Dossier où enregistrer les tableaux.
    """
    os.makedirs(dossier_sortie, exist_ok=True)  # Créer le dossier si nécessaire

    try:
        with pdfplumber.open(pdf_path) as pdf:
            for page_num, page in enumerate(pdf.pages):
                tableaux = page.extract_tables()
                for i, tableau in enumerate(tableaux):
                    fichier_csv = os.path.join(dossier_sortie, f"tableau_page_{page_num + 1}_tableau_{i + 1}.csv")
                    with open(fichier_csv, 'w', newline='', encoding='utf-8') as f:
                        writer = csv.writer(f)
                        writer.writerows(tableau)
                    print(f"Tableau enregistré : {fichier_csv}")
    except Exception as e:
        print(f"Erreur lors de l'extraction des tableaux : {e}")

# Exemple d'utilisation
if __name__ == "__main__":
    # Chemin du fichier PDF
    pdf_path = "mon_fichier.pdf"  # Remplace par le chemin réel de ton fichier PDF

    # Extraction du texte
    texte_extrait = extraire_texte_nettoye(pdf_path)
    print(texte_extrait[:500])  # Affiche un aperçu des 500 premiers caractères

    # Extraction des tableaux
    extraire_tableaux(pdf_path)
